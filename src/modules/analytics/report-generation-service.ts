// Report Generation Service - Module 55
import { getDataService } from '../core/data-service';
import { getAnalyticsService } from '../core/analytics-service';
import { getPerformanceMetricsService } from './performance-metrics-service';
import { getUsagePatternsService } from './usage-patterns-service';
import { getDataVisualizationService } from './data-visualization-service';
import { getTherapyGoalsService } from '../professional/therapy-goals-service';

interface ReportConfig {
  id: string;
  name: string;
  type: ReportType;
  sections: ReportSection[];
  schedule?: ReportSchedule;
  recipients?: string[];
  format: ReportFormat;
  branding?: ReportBranding;
  filters?: ReportFilter[];
}

type ReportType = 
  | 'progress' 
  | 'performance' 
  | 'clinical' 
  | 'educational' 
  | 'executive' 
  | 'custom';

type ReportFormat = 'pdf' | 'html' | 'csv' | 'json' | 'docx';

interface ReportSection {
  id: string;
  title: string;
  type: SectionType;
  dataSource: string;
  config: any;
  order: number;
  pageBreak?: boolean;
}

type SectionType = 
  | 'summary' 
  | 'chart' 
  | 'table' 
  | 'timeline' 
  | 'narrative' 
  | 'goals' 
  | 'recommendations';

interface ReportSchedule {
  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly';
  dayOfWeek?: number; // 0-6
  dayOfMonth?: number; // 1-31
  time?: string; // HH:MM
  timezone?: string;
  enabled: boolean;
}

interface ReportFilter {
  field: string;
  operator: 'equals' | 'contains' | 'between' | 'in';
  value: any;
}

interface ReportBranding {
  logo?: string;
  primaryColor: string;
  secondaryColor: string;
  fontFamily: string;
  headerText?: string;
  footerText?: string;
}

interface GeneratedReport {
  id: string;
  configId: string;
  generatedAt: Date;
  format: ReportFormat;
  content: any;
  metadata: ReportMetadata;
  url?: string;
}

interface ReportMetadata {
  title: string;
  subtitle?: string;
  dateRange: { start: Date; end: Date };
  generatedBy: string;
  totalPages?: number;
  sections: string[];
  filters: ReportFilter[];
}

interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  type: ReportType;
  thumbnail?: string;
  sections: TemplateSectionConfig[];
  defaultSchedule?: Partial<ReportSchedule>;
}

interface TemplateSectionConfig {
  type: SectionType;
  title: string;
  description: string;
  required: boolean;
  defaultConfig: any;
}

export class ReportGenerationService {
  private static instance: ReportGenerationService;
  private dataService = getDataService();
  private analyticsService = getAnalyticsService();
  private performanceMetricsService = getPerformanceMetricsService();
  private usagePatternsService = getUsagePatternsService();
  private dataVisualizationService = getDataVisualizationService();
  private therapyGoalsService = getTherapyGoalsService();
  
  private reportConfigs: Map<string, ReportConfig> = new Map();
  private generatedReports: Map<string, GeneratedReport> = new Map();
  private scheduleTimers: Map<string, NodeJS.Timeout> = new Map();
  private templates: Map<string, ReportTemplate> = new Map();
  
  private readonly defaultBranding: ReportBranding = {
    primaryColor: '#3B82F6',
    secondaryColor: '#10B981',
    fontFamily: 'Arial, sans-serif',
    headerText: 'TinkyBink AAC Report',
    footerText: 'Generated by TinkyBink AAC System'
  };

  private constructor() {
    this.initializeTemplates();
  }

  static getInstance(): ReportGenerationService {
    if (!ReportGenerationService.instance) {
      ReportGenerationService.instance = new ReportGenerationService();
    }
    return ReportGenerationService.instance;
  }

  initialize(): void {
    console.log('ReportGenerationService initializing...');
    this.loadSavedConfigs();
    this.startScheduledReports();
    this.setupEventListeners();
    console.log('ReportGenerationService initialized');
  }

  private initializeTemplates(): void {
    // Progress Report Template
    this.templates.set('progress-report', {
      id: 'progress-report',
      name: 'Progress Report',
      description: 'Comprehensive progress tracking with goals and achievements',
      type: 'progress',
      sections: [
        {
          type: 'summary',
          title: 'Executive Summary',
          description: 'High-level overview of progress',
          required: true,
          defaultConfig: { includeScore: true, includeTrends: true }
        },
        {
          type: 'chart',
          title: 'Performance Trends',
          description: 'Visual representation of key metrics over time',
          required: true,
          defaultConfig: { chartType: 'line', metrics: ['wpm', 'accuracy'] }
        },
        {
          type: 'goals',
          title: 'Goal Progress',
          description: 'Status of therapy goals',
          required: true,
          defaultConfig: { showCompleted: true, showActive: true }
        },
        {
          type: 'timeline',
          title: 'Milestones Achieved',
          description: 'Timeline of achievements',
          required: false,
          defaultConfig: { limit: 10 }
        },
        {
          type: 'recommendations',
          title: 'Recommendations',
          description: 'Suggested next steps',
          required: true,
          defaultConfig: { maxRecommendations: 5 }
        }
      ],
      defaultSchedule: {
        frequency: 'weekly',
        dayOfWeek: 5, // Friday
        time: '17:00'
      }
    });

    // Clinical Report Template
    this.templates.set('clinical-report', {
      id: 'clinical-report',
      name: 'Clinical Report',
      description: 'Detailed clinical assessment for healthcare providers',
      type: 'clinical',
      sections: [
        {
          type: 'summary',
          title: 'Patient Summary',
          description: 'Patient information and current status',
          required: true,
          defaultConfig: { includeBaseline: true }
        },
        {
          type: 'table',
          title: 'Detailed Metrics',
          description: 'Comprehensive metric breakdown',
          required: true,
          defaultConfig: { 
            metrics: 'all', 
            includeBaseline: true,
            includeNorms: true 
          }
        },
        {
          type: 'narrative',
          title: 'Clinical Observations',
          description: 'Narrative analysis of communication patterns',
          required: true,
          defaultConfig: { 
            sections: ['patterns', 'strengths', 'challenges'] 
          }
        },
        {
          type: 'goals',
          title: 'Treatment Goals',
          description: 'Progress on therapy objectives',
          required: true,
          defaultConfig: { 
            includeHistory: true,
            includeRecommendations: true 
          }
        }
      ],
      defaultSchedule: {
        frequency: 'monthly',
        dayOfMonth: 1
      }
    });

    // Educational Report Template
    this.templates.set('educational-report', {
      id: 'educational-report',
      name: 'Educational Report',
      description: 'Learning progress and educational achievements',
      type: 'educational',
      sections: [
        {
          type: 'summary',
          title: 'Learning Overview',
          description: 'Summary of educational progress',
          required: true,
          defaultConfig: { focusArea: 'vocabulary' }
        },
        {
          type: 'chart',
          title: 'Vocabulary Growth',
          description: 'Expansion of communication vocabulary',
          required: true,
          defaultConfig: { chartType: 'bar', groupBy: 'category' }
        },
        {
          type: 'table',
          title: 'Skill Assessment',
          description: 'Detailed skill breakdown',
          required: true,
          defaultConfig: { 
            skills: ['vocabulary', 'sentence_construction', 'independence'] 
          }
        },
        {
          type: 'timeline',
          title: 'Learning Milestones',
          description: 'Educational achievements timeline',
          required: false,
          defaultConfig: { category: 'educational' }
        }
      ]
    });

    // Executive Dashboard Template
    this.templates.set('executive-dashboard', {
      id: 'executive-dashboard',
      name: 'Executive Dashboard',
      description: 'High-level metrics for administrators',
      type: 'executive',
      sections: [
        {
          type: 'summary',
          title: 'Key Performance Indicators',
          description: 'Critical metrics at a glance',
          required: true,
          defaultConfig: { 
            kpis: ['engagement', 'progress', 'outcomes'] 
          }
        },
        {
          type: 'chart',
          title: 'Usage Analytics',
          description: 'System usage patterns',
          required: true,
          defaultConfig: { 
            chartType: 'heatmap',
            dataType: 'usage' 
          }
        },
        {
          type: 'table',
          title: 'User Statistics',
          description: 'Aggregate user data',
          required: true,
          defaultConfig: { 
            groupBy: 'cohort',
            metrics: ['sessions', 'duration', 'progress'] 
          }
        }
      ]
    });
  }

  private setupEventListeners(): void {
    // Auto-generate reports on significant events
    window.addEventListener('milestoneAchieved', () => {
      this.checkTriggeredReports('milestone');
    });

    window.addEventListener('goalCompleted', () => {
      this.checkTriggeredReports('goal');
    });

    window.addEventListener('monthEnd', () => {
      this.checkTriggeredReports('monthly');
    });
  }

  // Report Configuration
  async createReportConfig(
    name: string,
    type: ReportType,
    sections: ReportSection[],
    options?: Partial<ReportConfig>
  ): Promise<ReportConfig> {
    const config: ReportConfig = {
      id: `report-${Date.now()}`,
      name,
      type,
      sections: sections.sort((a, b) => a.order - b.order),
      format: 'pdf',
      branding: this.defaultBranding,
      ...options
    };

    this.reportConfigs.set(config.id, config);
    this.saveConfigs();

    if (config.schedule?.enabled) {
      this.scheduleReport(config);
    }

    this.analyticsService.trackEvent('report_config_created', {
      type,
      sections: sections.length,
      scheduled: !!config.schedule?.enabled
    });

    return config;
  }

  createReportFromTemplate(
    templateId: string,
    customizations?: {
      name?: string;
      sections?: Partial<ReportSection>[];
      schedule?: Partial<ReportSchedule>;
      branding?: Partial<ReportBranding>;
    }
  ): ReportConfig {
    const template = this.templates.get(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }

    const sections: ReportSection[] = template.sections.map((section, index) => ({
      id: `section-${index}`,
      title: section.title,
      type: section.type,
      dataSource: this.getDefaultDataSource(section.type),
      config: section.defaultConfig,
      order: index,
      ...(customizations?.sections?.[index] || {})
    }));

    const schedule = template.defaultSchedule ? {
      ...template.defaultSchedule,
      enabled: false,
      ...(customizations?.schedule || {})
    } as ReportSchedule : undefined;

    return this.createReportConfig(
      customizations?.name || template.name,
      template.type,
      sections,
      { 
        schedule,
        branding: { ...this.defaultBranding, ...customizations?.branding }
      }
    ) as any; // Type assertion for sync return
  }

  // Report Generation
  async generateReport(
    configId: string,
    options?: {
      dateRange?: { start: Date; end: Date };
      filters?: ReportFilter[];
      format?: ReportFormat;
    }
  ): Promise<GeneratedReport> {
    const config = this.reportConfigs.get(configId);
    if (!config) {
      throw new Error(`Report config ${configId} not found`);
    }

    const startTime = Date.now();
    
    // Prepare metadata
    const metadata: ReportMetadata = {
      title: config.name,
      subtitle: this.generateSubtitle(config, options?.dateRange),
      dateRange: options?.dateRange || this.getDefaultDateRange(config.type),
      generatedBy: this.getCurrentUser(),
      sections: config.sections.map(s => s.title),
      filters: [...(config.filters || []), ...(options?.filters || [])]
    };

    // Generate content for each section
    const content: any = {
      metadata,
      sections: []
    };

    for (const section of config.sections) {
      try {
        const sectionContent = await this.generateSection(section, metadata);
        content.sections.push({
          ...section,
          content: sectionContent
        });
      } catch (error) {
        console.error(`Error generating section ${section.id}:`, error);
        content.sections.push({
          ...section,
          content: { error: 'Failed to generate section' }
        });
      }
    }

    // Apply branding
    if (config.branding) {
      content.branding = config.branding;
    }

    // Format the report
    const format = options?.format || config.format;
    const formattedContent = await this.formatReport(content, format);

    const report: GeneratedReport = {
      id: `generated-${Date.now()}`,
      configId,
      generatedAt: new Date(),
      format,
      content: formattedContent,
      metadata
    };

    // Save generated report
    this.generatedReports.set(report.id, report);
    this.saveGeneratedReport(report);

    const generationTime = Date.now() - startTime;
    
    this.analyticsService.trackEvent('report_generated', {
      configId,
      type: config.type,
      format,
      sections: config.sections.length,
      generationTime
    });

    return report;
  }

  private async generateSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    switch (section.type) {
      case 'summary':
        return this.generateSummarySection(section, metadata);
      case 'chart':
        return this.generateChartSection(section, metadata);
      case 'table':
        return this.generateTableSection(section, metadata);
      case 'timeline':
        return this.generateTimelineSection(section, metadata);
      case 'narrative':
        return this.generateNarrativeSection(section, metadata);
      case 'goals':
        return this.generateGoalsSection(section, metadata);
      case 'recommendations':
        return this.generateRecommendationsSection(section, metadata);
      default:
        throw new Error(`Unknown section type: ${section.type}`);
    }
  }

  private async generateSummarySection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const report = await this.performanceMetricsService.generatePerformanceReport(
      this.getTimeframe(metadata.dateRange)
    );

    return {
      overallScore: report.summary.overallScore,
      improvementRate: report.summary.improvementRate,
      strongestAreas: report.summary.strongestAreas,
      areasForImprovement: report.summary.areasForImprovement,
      keyMetrics: this.extractKeyMetrics(report.metrics),
      periodHighlights: await this.generatePeriodHighlights(metadata.dateRange)
    };
  }

  private async generateChartSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const { chartType, metrics, dataType } = section.config;
    
    switch (chartType) {
      case 'line':
        return this.dataVisualizationService.createPerformanceChart(
          metrics[0],
          this.getTimeframe(metadata.dateRange)
        );
        
      case 'comparison':
        return this.dataVisualizationService.createComparisonChart(
          metrics,
          this.getTimeframe(metadata.dateRange)
        );
        
      case 'heatmap':
        return this.dataVisualizationService.createHeatmap(dataType);
        
      case 'radar':
        return this.dataVisualizationService.createProgressRadar();
        
      default:
        return null;
    }
  }

  private async generateTableSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const { metrics, groupBy, includeBaseline, includeNorms } = section.config;
    
    const allMetrics = metrics === 'all' 
      ? this.performanceMetricsService.getAllMetrics()
      : metrics.map((m: string) => this.performanceMetricsService.getMetric(m)).filter(Boolean);

    const tableData = allMetrics.map(metric => ({
      name: metric!.name,
      value: metric!.value,
      unit: metric!.unit,
      trend: metric!.trend,
      change: metric!.changePercentage,
      category: metric!.category,
      baseline: includeBaseline ? this.getBaselineValue(metric!.id) : undefined,
      norm: includeNorms ? this.getNormValue(metric!.id) : undefined
    }));

    if (groupBy) {
      return this.groupTableData(tableData, groupBy);
    }

    return tableData;
  }

  private async generateTimelineSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const { limit, category } = section.config;
    const milestones = this.performanceMetricsService.getMilestones(limit);
    
    const filteredMilestones = category
      ? milestones.filter(m => this.getMilestoneCategory(m) === category)
      : milestones;

    return this.dataVisualizationService.createMilestoneTimeline(limit);
  }

  private async generateNarrativeSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const { sections: narrativeSections } = section.config;
    const narrative: Record<string, string> = {};

    for (const narrativeType of narrativeSections) {
      switch (narrativeType) {
        case 'patterns':
          narrative.patterns = await this.generatePatternsNarrative(metadata.dateRange);
          break;
        case 'strengths':
          narrative.strengths = await this.generateStrengthsNarrative();
          break;
        case 'challenges':
          narrative.challenges = await this.generateChallengesNarrative();
          break;
        case 'progress':
          narrative.progress = await this.generateProgressNarrative(metadata.dateRange);
          break;
      }
    }

    return narrative;
  }

  private async generateGoalsSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const { showCompleted, showActive, includeHistory } = section.config;
    const performanceGoals = this.performanceMetricsService.getGoals(!showCompleted);
    const therapyGoals = await this.therapyGoalsService.getAllGoals();

    const goals = {
      performance: performanceGoals.filter(g => showActive || g.status === 'completed'),
      therapy: therapyGoals.filter(g => showActive || g.status === 'completed')
    };

    if (includeHistory) {
      goals.performance.forEach(goal => {
        (goal as any).history = this.getGoalHistory(goal.id);
      });
    }

    return goals;
  }

  private async generateRecommendationsSection(
    section: ReportSection,
    metadata: ReportMetadata
  ): Promise<any> {
    const { maxRecommendations } = section.config;
    
    // Gather data for recommendations
    const performanceReport = await this.performanceMetricsService.generatePerformanceReport();
    const patterns = await this.usagePatternsService.analyzeUsagePatterns();
    
    const recommendations = [
      ...performanceReport.recommendations,
      ...patterns.insights,
      ...this.generateCustomRecommendations(performanceReport, patterns)
    ];

    // Prioritize and limit recommendations
    return this.prioritizeRecommendations(recommendations)
      .slice(0, maxRecommendations)
      .map((rec, index) => ({
        priority: index + 1,
        recommendation: rec,
        category: this.categorizeRecommendation(rec)
      }));
  }

  // Formatting Methods
  private async formatReport(
    content: any,
    format: ReportFormat
  ): Promise<any> {
    switch (format) {
      case 'pdf':
        return this.formatPDF(content);
      case 'html':
        return this.formatHTML(content);
      case 'csv':
        return this.formatCSV(content);
      case 'json':
        return content; // Already in JSON format
      case 'docx':
        return this.formatDOCX(content);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  private formatPDF(content: any): any {
    // This would integrate with a PDF generation library
    // For now, return a structured object that could be converted to PDF
    return {
      format: 'pdf',
      pages: this.paginateContent(content),
      styles: this.generatePDFStyles(content.branding),
      metadata: {
        title: content.metadata.title,
        author: content.metadata.generatedBy,
        created: new Date().toISOString()
      }
    };
  }

  private formatHTML(content: any): string {
    const { metadata, sections, branding } = content;
    
    let html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${metadata.title}</title>
        <style>${this.generateHTMLStyles(branding)}</style>
      </head>
      <body>
        <header>
          <h1>${metadata.title}</h1>
          ${metadata.subtitle ? `<h2>${metadata.subtitle}</h2>` : ''}
        </header>
        <main>
    `;

    sections.forEach((section: any) => {
      html += this.formatHTMLSection(section);
    });

    html += `
        </main>
        <footer>
          <p>${branding?.footerText || ''}</p>
          <p>Generated on ${new Date().toLocaleString()}</p>
        </footer>
      </body>
      </html>
    `;

    return html;
  }

  private formatCSV(content: any): string {
    const csvRows: string[] = [];
    
    // Add metadata
    csvRows.push(`Report: ${content.metadata.title}`);
    csvRows.push(`Generated: ${new Date().toISOString()}`);
    csvRows.push(''); // Empty row
    
    // Process each section
    content.sections.forEach((section: any) => {
      if (section.type === 'table') {
        csvRows.push(section.title);
        csvRows.push(...this.tableToCSV(section.content));
        csvRows.push(''); // Empty row between sections
      }
    });

    return csvRows.join('\n');
  }

  private formatDOCX(content: any): any {
    // This would integrate with a DOCX generation library
    // For now, return a structured object
    return {
      format: 'docx',
      document: {
        sections: content.sections.map((section: any) => ({
          properties: {},
          children: this.sectionToDOCX(section)
        }))
      },
      styles: this.generateDOCXStyles(content.branding)
    };
  }

  // Helper Methods
  private generateSubtitle(config: ReportConfig, dateRange?: { start: Date; end: Date }): string {
    if (!dateRange) return '';
    
    const start = dateRange.start.toLocaleDateString();
    const end = dateRange.end.toLocaleDateString();
    return `${start} - ${end}`;
  }

  private getDefaultDateRange(type: ReportType): { start: Date; end: Date } {
    const end = new Date();
    const start = new Date();
    
    switch (type) {
      case 'progress':
      case 'educational':
        start.setDate(end.getDate() - 7); // Last week
        break;
      case 'clinical':
        start.setMonth(end.getMonth() - 1); // Last month
        break;
      case 'executive':
        start.setMonth(end.getMonth() - 3); // Last quarter
        break;
      default:
        start.setDate(end.getDate() - 30); // Last 30 days
    }
    
    return { start, end };
  }

  private getTimeframe(dateRange: { start: Date; end: Date }): 'day' | 'week' | 'month' {
    const days = (dateRange.end.getTime() - dateRange.start.getTime()) / (1000 * 60 * 60 * 24);
    
    if (days <= 1) return 'day';
    if (days <= 7) return 'week';
    return 'month';
  }

  private getCurrentUser(): string {
    return this.dataService.getData('current_user_name') || 'System';
  }

  private getDefaultDataSource(sectionType: SectionType): string {
    const sources: Record<SectionType, string> = {
      summary: 'performance.summary',
      chart: 'performance.metrics',
      table: 'performance.all',
      timeline: 'progress.milestones',
      narrative: 'analysis.patterns',
      goals: 'goals.all',
      recommendations: 'analysis.recommendations'
    };
    return sources[sectionType];
  }

  private extractKeyMetrics(metrics: any[]): any[] {
    return metrics
      .filter(m => ['words_per_minute', 'accuracy_rate', 'independence_score'].includes(m.id))
      .map(m => ({
        name: m.name,
        value: m.value,
        unit: m.unit,
        trend: m.trend
      }));
  }

  private async generatePeriodHighlights(dateRange: { start: Date; end: Date }): Promise<string[]> {
    const highlights: string[] = [];
    
    // Get milestones in period
    const milestones = this.performanceMetricsService.getMilestones()
      .filter(m => m.achievedAt >= dateRange.start && m.achievedAt <= dateRange.end);
    
    if (milestones.length > 0) {
      highlights.push(`Achieved ${milestones.length} milestone${milestones.length > 1 ? 's' : ''}`);
    }
    
    // Get usage stats
    const sessions = this.usagePatternsService.getSessionHistory()
      .filter(s => s.startTime >= dateRange.start && s.startTime <= dateRange.end);
    
    if (sessions.length > 0) {
      const totalMinutes = sessions.reduce((sum, s) => sum + s.duration, 0) / 60000;
      highlights.push(`${sessions.length} sessions totaling ${Math.round(totalMinutes)} minutes`);
    }
    
    return highlights;
  }

  private getBaselineValue(metricId: string): number {
    // This would fetch baseline values from initial assessment
    const baselines: Record<string, number> = {
      words_per_minute: 5,
      accuracy_rate: 60,
      vocabulary_growth: 0,
      independence_score: 20
    };
    return baselines[metricId] || 0;
  }

  private getNormValue(metricId: string): number {
    // This would fetch normative data
    const norms: Record<string, number> = {
      words_per_minute: 30,
      accuracy_rate: 85,
      vocabulary_growth: 500,
      independence_score: 75
    };
    return norms[metricId] || 0;
  }

  private groupTableData(data: any[], groupBy: string): any {
    const grouped: Record<string, any[]> = {};
    
    data.forEach(item => {
      const key = item[groupBy] || 'Other';
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(item);
    });
    
    return grouped;
  }

  private getMilestoneCategory(milestone: any): string {
    const metric = this.performanceMetricsService.getMetric(milestone.metric);
    return metric?.category || 'other';
  }

  private async generatePatternsNarrative(dateRange: { start: Date; end: Date }): Promise<string> {
    const patterns = await this.usagePatternsService.analyzeUsagePatterns();
    const peakTimes = await this.usagePatternsService.analyzePeakUsageTimes();
    
    let narrative = `During the period from ${dateRange.start.toLocaleDateString()} to ${dateRange.end.toLocaleDateString()}, `;
    narrative += `the user exhibited ${patterns.patterns.length} distinct usage patterns. `;
    
    if (peakTimes.length > 0) {
      const topPeak = peakTimes[0];
      narrative += `Peak usage occurred at ${topPeak.hour}:00 on ${this.getDayName(topPeak.dayOfWeek)}, `;
      narrative += `with an average session duration of ${Math.round(topPeak.avgDuration / 60000)} minutes. `;
    }
    
    const habits = patterns.habits.filter(h => h.consistency > 0.7);
    if (habits.length > 0) {
      narrative += `Strong habits include ${habits.map(h => h.habit).join(', ')}. `;
    }
    
    return narrative;
  }

  private async generateStrengthsNarrative(): Promise<string> {
    const metrics = this.performanceMetricsService.getAllMetrics();
    const strengths = metrics
      .filter(m => m.trend === 'up' || m.value > 80)
      .sort((a, b) => b.changePercentage - a.changePercentage)
      .slice(0, 3);
    
    if (strengths.length === 0) {
      return 'The user demonstrates consistent performance across all metrics.';
    }
    
    let narrative = 'Key strengths include ';
    narrative += strengths.map((s, i) => {
      if (i === strengths.length - 1 && strengths.length > 1) return `and ${s.name}`;
      return s.name;
    }).join(', ');
    
    narrative += '. ';
    
    const topStrength = strengths[0];
    if (topStrength.trend === 'up') {
      narrative += `${topStrength.name} has shown particularly strong improvement with a ${topStrength.changePercentage.toFixed(1)}% increase. `;
    }
    
    return narrative;
  }

  private async generateChallengesNarrative(): Promise<string> {
    const metrics = this.performanceMetricsService.getAllMetrics();
    const challenges = metrics
      .filter(m => m.trend === 'down' || m.value < 50)
      .sort((a, b) => a.value - b.value)
      .slice(0, 3);
    
    if (challenges.length === 0) {
      return 'No significant challenges were identified during this period.';
    }
    
    let narrative = 'Areas requiring attention include ';
    narrative += challenges.map((c, i) => {
      if (i === challenges.length - 1 && challenges.length > 1) return `and ${c.name}`;
      return c.name;
    }).join(', ');
    
    narrative += '. ';
    
    const topChallenge = challenges[0];
    narrative += `Focus on improving ${topChallenge.name} (currently at ${topChallenge.value}${topChallenge.unit}) is recommended. `;
    
    return narrative;
  }

  private async generateProgressNarrative(dateRange: { start: Date; end: Date }): Promise<string> {
    const report = await this.performanceMetricsService.generatePerformanceReport();
    const overallScore = report.summary.overallScore;
    const improvementRate = report.summary.improvementRate;
    
    let narrative = `Overall performance score is ${overallScore.toFixed(1)}%, `;
    
    if (improvementRate > 0) {
      narrative += `representing a ${improvementRate.toFixed(1)}% improvement over the previous period. `;
    } else if (improvementRate < 0) {
      narrative += `showing a ${Math.abs(improvementRate).toFixed(1)}% decline from the previous period. `;
    } else {
      narrative += `maintaining steady performance. `;
    }
    
    const milestones = this.performanceMetricsService.getMilestones()
      .filter(m => m.achievedAt >= dateRange.start && m.achievedAt <= dateRange.end);
    
    if (milestones.length > 0) {
      narrative += `${milestones.length} milestone${milestones.length > 1 ? 's were' : ' was'} achieved during this period. `;
    }
    
    return narrative;
  }

  private generateCustomRecommendations(performanceReport: any, patterns: any): string[] {
    const recommendations: string[] = [];
    
    // Check for inconsistent usage
    const habits = patterns.habits;
    const decliningHabits = habits.filter((h: any) => h.strengthTrend === 'decreasing');
    if (decliningHabits.length > 0) {
      recommendations.push('Establish a more consistent daily routine to maintain progress.');
    }
    
    // Check for plateau in progress
    const metrics = performanceReport.metrics;
    const stableMetrics = metrics.filter((m: any) => m.trend === 'stable');
    if (stableMetrics.length > metrics.length * 0.7) {
      recommendations.push('Consider introducing new challenges to break through the current plateau.');
    }
    
    // Check for time of day optimization
    const peakTimes = patterns.peakTimes || [];
    if (peakTimes.length > 0 && peakTimes[0].avgProductivity > 80) {
      recommendations.push(`Schedule important activities during peak performance time at ${peakTimes[0].hour}:00.`);
    }
    
    return recommendations;
  }

  private prioritizeRecommendations(recommendations: string[]): string[] {
    // Remove duplicates
    const unique = Array.from(new Set(recommendations));
    
    // Sort by importance (basic heuristic)
    return unique.sort((a, b) => {
      // Prioritize safety/error-related recommendations
      if (a.toLowerCase().includes('error') || a.toLowerCase().includes('accuracy')) return -1;
      if (b.toLowerCase().includes('error') || b.toLowerCase().includes('accuracy')) return 1;
      
      // Then progress-related
      if (a.toLowerCase().includes('progress') || a.toLowerCase().includes('improve')) return -1;
      if (b.toLowerCase().includes('progress') || b.toLowerCase().includes('improve')) return 1;
      
      return 0;
    });
  }

  private categorizeRecommendation(recommendation: string): string {
    const categories = {
      performance: ['speed', 'accuracy', 'efficiency'],
      engagement: ['session', 'time', 'consistent'],
      learning: ['vocabulary', 'skill', 'challenge'],
      support: ['help', 'assistance', 'guidance']
    };
    
    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(keyword => recommendation.toLowerCase().includes(keyword))) {
        return category;
      }
    }
    
    return 'general';
  }

  private generateHTMLStyles(branding?: ReportBranding): string {
    const b = branding || this.defaultBranding;
    return `
      body {
        font-family: ${b.fontFamily};
        color: #333;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      h1, h2, h3 {
        color: ${b.primaryColor};
      }
      header {
        border-bottom: 3px solid ${b.primaryColor};
        margin-bottom: 30px;
        padding-bottom: 20px;
      }
      .section {
        margin-bottom: 40px;
        page-break-inside: avoid;
      }
      .chart-container {
        margin: 20px 0;
        text-align: center;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: ${b.secondaryColor};
        color: white;
      }
      .metric-value {
        font-size: 24px;
        font-weight: bold;
        color: ${b.primaryColor};
      }
      .trend-up { color: ${b.secondaryColor}; }
      .trend-down { color: #EF4444; }
      footer {
        border-top: 1px solid #ddd;
        margin-top: 50px;
        padding-top: 20px;
        text-align: center;
        color: #666;
      }
    `;
  }

  private generatePDFStyles(branding?: ReportBranding): any {
    const b = branding || this.defaultBranding;
    return {
      defaultStyle: {
        font: b.fontFamily.split(',')[0].trim(),
        fontSize: 11,
        color: '#333333'
      },
      styles: {
        header: {
          fontSize: 22,
          bold: true,
          color: b.primaryColor,
          margin: [0, 0, 0, 10]
        },
        subheader: {
          fontSize: 16,
          bold: true,
          color: b.primaryColor,
          margin: [0, 10, 0, 5]
        },
        metric: {
          fontSize: 18,
          bold: true,
          color: b.primaryColor
        }
      }
    };
  }

  private generateDOCXStyles(branding?: ReportBranding): any {
    const b = branding || this.defaultBranding;
    return {
      paragraphStyles: [
        {
          id: 'Heading1',
          name: 'Heading 1',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 28,
            bold: true,
            color: b.primaryColor.replace('#', '')
          }
        }
      ]
    };
  }

  private formatHTMLSection(section: any): string {
    let html = `<div class="section">`;
    html += `<h2>${section.title}</h2>`;
    
    switch (section.type) {
      case 'summary':
        html += this.formatHTMLSummary(section.content);
        break;
      case 'chart':
        html += `<div class="chart-container">[Chart: ${section.title}]</div>`;
        break;
      case 'table':
        html += this.formatHTMLTable(section.content);
        break;
      case 'timeline':
        html += this.formatHTMLTimeline(section.content);
        break;
      case 'narrative':
        html += this.formatHTMLNarrative(section.content);
        break;
      case 'goals':
        html += this.formatHTMLGoals(section.content);
        break;
      case 'recommendations':
        html += this.formatHTMLRecommendations(section.content);
        break;
    }
    
    html += `</div>`;
    return html;
  }

  private formatHTMLSummary(content: any): string {
    return `
      <div class="summary">
        <p>Overall Score: <span class="metric-value">${content.overallScore.toFixed(1)}%</span></p>
        <p>Improvement Rate: <span class="trend-${content.improvementRate > 0 ? 'up' : 'down'}">${content.improvementRate.toFixed(1)}%</span></p>
        <h3>Strongest Areas</h3>
        <ul>${content.strongestAreas.map((area: string) => `<li>${area}</li>`).join('')}</ul>
        <h3>Areas for Improvement</h3>
        <ul>${content.areasForImprovement.map((area: string) => `<li>${area}</li>`).join('')}</ul>
      </div>
    `;
  }

  private formatHTMLTable(content: any): string {
    if (Array.isArray(content)) {
      // Simple table
      const headers = Object.keys(content[0] || {});
      return `
        <table>
          <thead>
            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
          </thead>
          <tbody>
            ${content.map((row: any) => 
              `<tr>${headers.map(h => `<td>${row[h]}</td>`).join('')}</tr>`
            ).join('')}
          </tbody>
        </table>
      `;
    } else {
      // Grouped table
      let html = '';
      Object.entries(content).forEach(([group, rows]: [string, any]) => {
        html += `<h3>${group}</h3>`;
        html += this.formatHTMLTable(rows);
      });
      return html;
    }
  }

  private formatHTMLTimeline(content: any): string {
    return `
      <div class="timeline">
        ${content.milestones.map((m: any) => `
          <div class="milestone">
            <span class="icon">${m.icon}</span>
            <strong>${m.title}</strong> - ${m.date.toLocaleDateString()}
            <p>${m.description}</p>
          </div>
        `).join('')}
      </div>
    `;
  }

  private formatHTMLNarrative(content: any): string {
    return Object.entries(content)
      .map(([section, text]) => `
        <div class="narrative-section">
          <h3>${section.charAt(0).toUpperCase() + section.slice(1)}</h3>
          <p>${text}</p>
        </div>
      `).join('');
  }

  private formatHTMLGoals(content: any): string {
    let html = '<div class="goals">';
    
    if (content.performance?.length > 0) {
      html += '<h3>Performance Goals</h3><ul>';
      content.performance.forEach((goal: any) => {
        html += `<li>${goal.metric}: ${goal.progress.toFixed(1)}% complete</li>`;
      });
      html += '</ul>';
    }
    
    if (content.therapy?.length > 0) {
      html += '<h3>Therapy Goals</h3><ul>';
      content.therapy.forEach((goal: any) => {
        html += `<li>${goal.name}: ${goal.status}</li>`;
      });
      html += '</ul>';
    }
    
    html += '</div>';
    return html;
  }

  private formatHTMLRecommendations(content: any): string {
    return `
      <ol>
        ${content.map((rec: any) => 
          `<li><strong>${rec.category}:</strong> ${rec.recommendation}</li>`
        ).join('')}
      </ol>
    `;
  }

  private tableToCSV(data: any[]): string[] {
    if (!Array.isArray(data) || data.length === 0) return [];
    
    const headers = Object.keys(data[0]);
    const rows = [headers.join(',')];
    
    data.forEach(row => {
      const values = headers.map(h => {
        const value = row[h];
        // Escape values containing commas or quotes
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      });
      rows.push(values.join(','));
    });
    
    return rows;
  }

  private sectionToDOCX(section: any): any[] {
    // Convert section content to DOCX format
    return [
      {
        type: 'paragraph',
        options: {
          heading: 'Heading2'
        },
        children: [{ text: section.title }]
      },
      // Additional content based on section type
    ];
  }

  private paginateContent(content: any): any[] {
    // Split content into pages for PDF
    const pages: any[] = [];
    let currentPage: any = { content: [] };
    
    content.sections.forEach((section: any) => {
      if (section.pageBreak && currentPage.content.length > 0) {
        pages.push(currentPage);
        currentPage = { content: [] };
      }
      currentPage.content.push(section);
    });
    
    if (currentPage.content.length > 0) {
      pages.push(currentPage);
    }
    
    return pages;
  }

  private getDayName(day?: number): string {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return day !== undefined ? days[day] : 'weekdays';
  }

  private getGoalHistory(goalId: string): any[] {
    // This would fetch historical progress data for a goal
    return [];
  }

  // Scheduling Methods
  private scheduleReport(config: ReportConfig): void {
    if (!config.schedule || !config.schedule.enabled) return;
    
    const { frequency, dayOfWeek, dayOfMonth, time } = config.schedule;
    
    // Clear existing timer if any
    if (this.scheduleTimers.has(config.id)) {
      clearInterval(this.scheduleTimers.get(config.id)!);
    }
    
    // Calculate next run time
    const nextRun = this.calculateNextRunTime(config.schedule);
    const delay = nextRun.getTime() - Date.now();
    
    // Schedule the report
    const timer = setTimeout(() => {
      this.generateScheduledReport(config);
      // Reschedule for next occurrence
      this.scheduleReport(config);
    }, delay);
    
    this.scheduleTimers.set(config.id, timer);
  }

  private calculateNextRunTime(schedule: ReportSchedule): Date {
    const now = new Date();
    const next = new Date();
    
    // Parse time
    if (schedule.time) {
      const [hours, minutes] = schedule.time.split(':').map(Number);
      next.setHours(hours, minutes, 0, 0);
    }
    
    switch (schedule.frequency) {
      case 'daily':
        if (next <= now) {
          next.setDate(next.getDate() + 1);
        }
        break;
        
      case 'weekly':
        const targetDay = schedule.dayOfWeek || 1; // Default Monday
        next.setDate(next.getDate() + (targetDay - next.getDay() + 7) % 7);
        if (next <= now) {
          next.setDate(next.getDate() + 7);
        }
        break;
        
      case 'monthly':
        const targetDate = schedule.dayOfMonth || 1;
        next.setDate(targetDate);
        if (next <= now) {
          next.setMonth(next.getMonth() + 1);
        }
        break;
        
      case 'quarterly':
        // First day of next quarter
        const quarter = Math.floor(now.getMonth() / 3);
        next.setMonth((quarter + 1) * 3, 1);
        break;
    }
    
    return next;
  }

  private async generateScheduledReport(config: ReportConfig): Promise<void> {
    try {
      const report = await this.generateReport(config.id);
      
      // Send to recipients
      if (config.recipients && config.recipients.length > 0) {
        await this.sendReport(report, config.recipients);
      }
      
      this.analyticsService.trackEvent('scheduled_report_generated', {
        configId: config.id,
        type: config.type,
        recipients: config.recipients?.length || 0
      });
    } catch (error) {
      console.error(`Failed to generate scheduled report ${config.id}:`, error);
    }
  }

  private async sendReport(report: GeneratedReport, recipients: string[]): Promise<void> {
    // This would integrate with an email service
    // For now, just save to a "sent reports" list
    const sentReports = this.dataService.getData('sent_reports') || [];
    sentReports.push({
      reportId: report.id,
      recipients,
      sentAt: new Date().toISOString()
    });
    this.dataService.setData('sent_reports', sentReports);
  }

  private checkTriggeredReports(trigger: string): void {
    this.reportConfigs.forEach(config => {
      if (config.schedule?.frequency === trigger) {
        this.generateReport(config.id);
      }
    });
  }

  private startScheduledReports(): void {
    this.reportConfigs.forEach(config => {
      if (config.schedule?.enabled) {
        this.scheduleReport(config);
      }
    });
  }

  // Data Persistence
  private loadSavedConfigs(): void {
    const saved = this.dataService.getData('report_configs');
    if (saved) {
      Object.entries(saved).forEach(([id, config]: [string, any]) => {
        this.reportConfigs.set(id, config);
      });
    }
  }

  private saveConfigs(): void {
    const configs: Record<string, ReportConfig> = {};
    this.reportConfigs.forEach((config, id) => {
      configs[id] = config;
    });
    this.dataService.setData('report_configs', configs);
  }

  private saveGeneratedReport(report: GeneratedReport): void {
    const reports = this.dataService.getData('generated_reports') || [];
    reports.push({
      ...report,
      content: undefined // Don't save full content to localStorage
    });
    
    // Keep only last 100 reports
    if (reports.length > 100) {
      reports.shift();
    }
    
    this.dataService.setData('generated_reports', reports);
  }

  // Public API
  getReportConfig(configId: string): ReportConfig | undefined {
    return this.reportConfigs.get(configId);
  }

  getAllReportConfigs(): ReportConfig[] {
    return Array.from(this.reportConfigs.values());
  }

  getGeneratedReport(reportId: string): GeneratedReport | undefined {
    return this.generatedReports.get(reportId);
  }

  getReportHistory(limit: number = 50): any[] {
    const history = this.dataService.getData('generated_reports') || [];
    return history.slice(-limit);
  }

  getTemplates(): ReportTemplate[] {
    return Array.from(this.templates.values());
  }

  updateReportConfig(configId: string, updates: Partial<ReportConfig>): void {
    const config = this.reportConfigs.get(configId);
    if (!config) return;
    
    Object.assign(config, updates);
    
    // Update schedule if needed
    if ('schedule' in updates) {
      if (updates.schedule?.enabled) {
        this.scheduleReport(config);
      } else {
        // Cancel scheduled reports
        if (this.scheduleTimers.has(configId)) {
          clearTimeout(this.scheduleTimers.get(configId)!);
          this.scheduleTimers.delete(configId);
        }
      }
    }
    
    this.saveConfigs();
  }

  deleteReportConfig(configId: string): void {
    // Cancel any scheduled reports
    if (this.scheduleTimers.has(configId)) {
      clearTimeout(this.scheduleTimers.get(configId)!);
      this.scheduleTimers.delete(configId);
    }
    
    this.reportConfigs.delete(configId);
    this.saveConfigs();
  }

  exportReportConfig(configId: string): any {
    const config = this.reportConfigs.get(configId);
    if (!config) return null;
    
    return {
      config,
      exportDate: new Date().toISOString(),
      version: '1.0'
    };
  }

  importReportConfig(data: any): ReportConfig {
    const config = data.config;
    config.id = `report-${Date.now()}`; // Generate new ID
    
    this.reportConfigs.set(config.id, config);
    this.saveConfigs();
    
    if (config.schedule?.enabled) {
      this.scheduleReport(config);
    }
    
    return config;
  }

  // Cleanup
  destroy(): void {
    // Clear all scheduled reports
    this.scheduleTimers.forEach(timer => clearTimeout(timer));
    this.scheduleTimers.clear();
    
    // Save state
    this.saveConfigs();
  }
}

export function getReportGenerationService(): ReportGenerationService {
  return ReportGenerationService.getInstance();
}